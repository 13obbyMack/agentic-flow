# WASM Integration Guide

This document provides integration instructions for the agent-booster-wasm module once the core library API is complete.

## Current Status

**WASM Bindings**: ✅ Complete and ready
**Core Library API**: ⏳ In Progress (waiting for `apply_edit` function)

## Integration Checklist

### Phase 1: Core Library Completion (Blocked)

- [ ] Core library implements the `apply_edit` function
- [ ] Core library exports public API in `lib.rs`
- [ ] Core library passes all tests

### Phase 2: WASM Integration (Ready to Execute)

Once the core library is ready, update `/workspaces/agentic-flow/agent-booster/crates/agent-booster-wasm/src/lib.rs`:

1. **Import the core function**:
   ```rust
   use agent_booster::apply_edit; // or whatever the function is called
   ```

2. **Implement `AgentBoosterWasm::apply_edit`**:
   ```rust
   pub fn apply_edit(
       &self,
       original_code: &str,
       edit_snippet: &str,
       language: WasmLanguage,
   ) -> Result<WasmEditResult, JsValue> {
       let request = EditRequest {
           original_code: original_code.to_string(),
           edit_snippet: edit_snippet.to_string(),
           language: language.into(),
           confidence_threshold: self.config.confidence_threshold,
       };

       let result = apply_edit(request)
           .map_err(|e| JsValue::from_str(&e.to_string()))?;

       Ok(WasmEditResult { inner: result })
   }
   ```

3. **Implement `apply_edit_json`**:
   ```rust
   pub fn apply_edit_json(&self, request_json: &str) -> Result<WasmEditResult, JsValue> {
       let request: EditRequest = serde_json::from_str(request_json)
           .map_err(|e| JsValue::from_str(&e.to_string()))?;

       let result = apply_edit(request)
           .map_err(|e| JsValue::from_str(&e.to_string()))?;

       Ok(WasmEditResult { inner: result })
   }
   ```

### Phase 3: Build & Test

```bash
# Install prerequisites (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup target add wasm32-unknown-unknown
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

# Build
cd /workspaces/agentic-flow/agent-booster/crates/agent-booster-wasm
./build.sh nodejs

# Test
wasm-pack test --node

# Build for all targets
./build.sh all
```

### Phase 4: NPM Package

1. **Verify package.json** (generated by wasm-pack):
   ```bash
   cat pkg/package.json
   ```

2. **Test locally**:
   ```bash
   cd pkg
   npm link

   # In another project
   npm link agent-booster-wasm
   ```

3. **Publish to npm**:
   ```bash
   cd pkg
   npm publish
   ```

## Usage Examples

### Node.js

```javascript
// CommonJS
const { AgentBoosterWasm, WasmLanguage } = require('agent-booster-wasm');

// ESM
import { AgentBoosterWasm, WasmLanguage } from 'agent-booster-wasm';

const booster = new AgentBoosterWasm();
const language = AgentBoosterWasm.parse_language('typescript');

const originalCode = `
function greet(name) {
  console.log("Hello " + name);
}
`;

const editSnippet = `
function greet(name) {
  console.log(\`Hello \${name}!\`);
}
`;

try {
  const result = booster.apply_edit(originalCode, editSnippet, language);
  console.log('Success!');
  console.log('Confidence:', result.confidence);
  console.log('Merged code:', result.merged_code);
} catch (error) {
  console.error('Edit failed:', error);
}
```

### Web Browser

```html
<!DOCTYPE html>
<html>
<head>
  <script type="module">
    import init, { AgentBoosterWasm, WasmLanguage } from './pkg/agent_booster_wasm.js';

    async function run() {
      await init(); // Initialize the WASM module

      const booster = new AgentBoosterWasm();
      const language = AgentBoosterWasm.parse_language('javascript');

      // Use the booster...
    }

    run();
  </script>
</head>
<body>
  <h1>Agent Booster WASM Demo</h1>
</body>
</html>
```

### Webpack/Bundler

```javascript
import { AgentBoosterWasm } from 'agent-booster-wasm';

const booster = new AgentBoosterWasm();

// Configure webpack to handle WASM
// In webpack.config.js:
module.exports = {
  experiments: {
    asyncWebAssembly: true
  }
};
```

## Performance Benchmarks

Once integrated, run benchmarks:

```bash
# Create a benchmark script
cat > benchmark.js << 'EOF'
const { AgentBoosterWasm, WasmLanguage } = require('./pkg');

const booster = new AgentBoosterWasm();
const language = AgentBoosterWasm.parse_language('javascript');

const code = `
// Generate some test code
${'const x = 1;\n'.repeat(100)}
`;

const edit = 'const x = 2;\n';

console.time('apply_edit');
for (let i = 0; i < 100; i++) {
  booster.apply_edit(code, edit, language);
}
console.timeEnd('apply_edit');
EOF

node benchmark.js
```

## Monitoring Integration Status

The WASM builder agent stores its progress in the memory coordination system:

```bash
# Check status via MCP
mcp__claude-flow__memory_usage {
  action: "retrieve",
  key: "wasm-progress",
  namespace: "agent-booster-swarm"
}
```

Status values:
- `waiting` - Waiting for core library completion
- `integrating` - Adding core library integration
- `testing` - Running build and tests
- `completed` - Ready for use
- `failed` - Integration encountered errors

## Troubleshooting

### Common Build Issues

1. **"wasm-bindgen version mismatch"**
   ```bash
   cargo update -p wasm-bindgen
   ```

2. **"Cannot find wasm32-unknown-unknown"**
   ```bash
   rustup target add wasm32-unknown-unknown
   ```

3. **"Core library not found"**
   - Ensure the core library builds successfully first
   - Check that workspace members are correctly configured

### Runtime Issues

1. **"Memory access out of bounds"**
   - Check input data sizes
   - Consider increasing WASM memory limits

2. **"Import resolution failed"**
   - Verify the correct build target (nodejs/web/bundler)
   - Check that all imports are properly configured

## Next Steps After Integration

1. **Add comprehensive tests**:
   - Unit tests for all public functions
   - Integration tests with real code samples
   - Performance benchmarks

2. **Optimize binary size**:
   - Profile which features add the most size
   - Consider feature flags for optional functionality
   - Investigate `wasm-opt` for additional optimization

3. **Documentation**:
   - Add TypeScript type definitions
   - Create interactive examples
   - Write migration guides from other tools

4. **CI/CD**:
   - Automate WASM builds
   - Run tests on multiple platforms
   - Publish to npm automatically on release

## Communication

Update other agents when status changes:

```javascript
// When integration starts
mcp__claude-flow__memory_usage({
  action: "store",
  key: "wasm-progress",
  namespace: "agent-booster-swarm",
  value: JSON.stringify({
    status: "integrating",
    phase: "adding_core_api",
    timestamp: new Date().toISOString()
  })
});

// When complete
mcp__claude-flow__memory_usage({
  action: "store",
  key: "wasm-progress",
  namespace: "agent-booster-swarm",
  value: JSON.stringify({
    status: "completed",
    build_targets: ["nodejs", "web", "bundler"],
    tests_passing: true,
    timestamp: new Date().toISOString()
  })
});
```
